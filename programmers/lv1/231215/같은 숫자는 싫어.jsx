// 같은 숫자는 싫어
// https://school.programmers.co.kr/learn/courses/30/lessons/12906

const solution = arr => arr.filter((v, i) => i === 0 || (i > 0 && arr[i-1] !== v));
// 반복문을 통해 풀었을 때, 정확성 테스트 케이스는 전부 통과하였으나, 효율성 테스트 케이스에서 실패
// filter를 통해 푼 결과, 효율성 테스트 케이스도 전부 통과하였다.
// 아무래도 이 경우 반복문보다는 filter가 더 효율적인 듯.

// 다른 사람 풀이 - 나는 이전 숫자와 비교하였으나, 이 사람은 다음 숫자와 비교하여 더 간결함.
function solution(arr)
{
    return arr.filter((val,index) => val !== arr[index+1]);
}

// 다른 사람 풀이 - 반복문 - 이 사람의 반복문과 내가 사용했던 반복문이 크게 다르지 않은데 이 사람은 통과가 되었다?
function solution(arr) {
    var answer = [arr[0]];

    for (let i=1; i<arr.length; i++) {
        if (answer[answer.length - 1] !== arr[i]) {
            answer.push(arr[i]);
        }
    }

    return answer;
}
// 내 경우 반복문 풀이에 shift를 넣었는데, 그 때문인지도 모르겠다. 단순히 반복과 비교 조건과 push만 넣은 게 더 효율적인가보다.
// 그렇다면 filter가 효율적인가 반복문이 효율적인가에 대한 의문은 아직 미지수로 볼 수 있겠다.

// 테스트 케이스

// 위 반복문
// 정확성 테스트
// 테스트 14 〉	통과 (0.13ms, 33.5MB)
// 테스트 15 〉	통과 (0.12ms, 33.5MB)
// 테스트 16 〉	통과 (0.16ms, 33.5MB)
// 테스트 17 〉	통과 (0.04ms, 33.5MB)
// 효율성  테스트
// 테스트 1 〉	통과 (41.80ms, 83.3MB)
// 테스트 2 〉	통과 (37.92ms, 83.1MB)
// 테스트 3 〉	통과 (33.54ms, 82.9MB)
// 테스트 4 〉	통과 (34.29ms, 83MB)

// 내 풀이 - filter
// 정확성 테스트
// 테스트 14 〉	통과 (0.06ms, 33.3MB)
// 테스트 15 〉	통과 (0.05ms, 33.5MB)
// 테스트 16 〉	통과 (0.08ms, 33.5MB)
// 테스트 17 〉	통과 (0.05ms, 33.4MB)
// 효율성  테스트
// 테스트 1 〉	통과 (25.56ms, 83.1MB)
// 테스트 2 〉	통과 (44.21ms, 81.5MB)
// 테스트 3 〉	통과 (25.07ms, 83.2MB)
// 테스트 4 〉	통과 (27.86ms, 83.7MB)

// 다른 사람 풀이 - filter - 첫 번째 다른 사람 풀이 - 다음 숫자와 비교하는 필터
// 정확성 테스트
// 테스트 14 〉	통과 (0.04ms, 33.4MB)
// 테스트 15 〉	통과 (0.05ms, 33.6MB)
// 테스트 16 〉	통과 (0.05ms, 33.4MB)
// 테스트 17 〉	통과 (0.03ms, 33.5MB)
// 효율성  테스트
// 테스트 1 〉	통과 (24.67ms, 83.3MB)
// 테스트 2 〉	통과 (25.07ms, 83.4MB)
// 테스트 3 〉	통과 (24.91ms, 83MB)
// 테스트 4 〉	통과 (27.84ms, 83.2MB)

// 결론: 반복문이 느리고, filter가 빠르다. 내 풀이가 조금 더 비효율적인 연산이라, 약간의 시간차가 생기지만 크게 다르지 않다.


// 다른 사람 풀이 - 역방향 비교, 닌자 코드를 날렸네
function solution(_) { return _.filter((i,$)=>i!=_[--$]) }

function solution(arr) { return arr.filter((v, i) => v !== arr[--i]); } 